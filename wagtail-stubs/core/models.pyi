from .utils import (
    find_available_slug as find_available_slug,
    get_content_languages as get_content_languages,
    get_supported_content_language_variant as get_supported_content_language_variant,
)
from collections import namedtuple
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
from django.db import migrations, models
from django.http import HttpRequest
from modelcluster.models import ClusterableModel
from treebeard.mp_tree import MP_Node
from typing import Any, Callable, Dict, Optional, NamedTuple, Collection as TypingCollection
from wagtail.admin.edit_handlers import EditHandler
from wagtail.core.forms import TaskStateCommentForm as TaskStateCommentForm
from wagtail.core.query import (
    PageQuerySet as PageQuerySet,
    TreeQuerySet as TreeQuerySet,
)
from wagtail.search.index import BaseField, RelatedFields
from wagtail.core.signals import (
    page_published as page_published,
    page_unpublished as page_unpublished,
    post_page_move as post_page_move,
    pre_page_move as pre_page_move,
    task_approved as task_approved,
    task_cancelled as task_cancelled,
    task_rejected as task_rejected,
    task_submitted as task_submitted,
    workflow_approved as workflow_approved,
    workflow_cancelled as workflow_cancelled,
    workflow_rejected as workflow_rejected,
    workflow_submitted as workflow_submitted,
)
from wagtail.core.sites import get_site_for_hostname as get_site_for_hostname
from wagtail.core.treebeard import TreebeardPathFixMixin as TreebeardPathFixMixin
from wagtail.core.url_routing import RouteResult as RouteResult
from wagtail.core.utils import (
    WAGTAIL_APPEND_SLASH as WAGTAIL_APPEND_SLASH,
    camelcase_to_underscore as camelcase_to_underscore,
    resolve_model_string as resolve_model_string,
)
from wagtail.search import index as index

PAGE_TEMPLATE_VAR: str

class SiteManager(models.Manager[Site]):
    def get_queryset(self) -> models.Manager[Site]: ...
    def get_by_natural_key(self, hostname: str, port: int) -> Site: ...

class SiteRootPath(NamedTuple):
    site_id: Any
    root_path: str
    root_url: str
    language_code: str

class Site(models.Model):
    hostname: models.CharField = ...
    port: models.IntegerField = ...
    site_name: models.CharField = ...
    root_page: models.ForeignKey = ...
    is_default_site: models.BooleanField = ...
    objects: SiteManager = ...
    def natural_key(self) -> Tuple[str, int]: ...
    @staticmethod
    def find_for_request(request: HttpRequest) -> Site: ...
    @property
    def root_url(self) -> str: ...
    def clean_fields(self, exclude: Optional[TypingCollection[str]] = ...) -> None: ...
    @staticmethod
    def get_site_root_paths() -> SiteRootPath: ...

def pk(obj: Any) -> Any: ...

class LocaleManager(models.Manager[Locale]):
    def get_queryset(self) -> models.Manager[Locale]: ...
    def get_for_language(self, language_code: str) -> Locale: ...

class Locale(models.Model):
    language_code: models.CharField = ...
    objects: LocaleManager = ...
    all_objects: models.Manager[Locale] = ...
    @classmethod
    def get_default(cls) -> Locale: ...
    @classmethod
    def get_active(cls) -> Locale: ...
    def delete(
        self, using: Any = ..., keep_parents: bool = ...
    ) -> Tuple[int, Dict[str, int]]: ...
    def language_code_is_valid(self) -> bool: ...
    def get_display_name(self) -> str: ...

class TranslatableMixin(models.Model):
    translation_key: models.UUIDField = ...
    locale: models.ForeignKey = ...
    @property
    def localized(self) -> models.Model: ...
    def get_translations(self, inclusive: bool = ...) -> models.QuerySet: ...
    def get_translation(self, locale: Locale) -> models.Model: ...
    def get_translation_or_none(self, locale: Locale) -> Optional[models.Model]: ...
    def has_translation(self, locale: Locale) -> bool: ...
    def copy_for_translation(self, locale: Locale) -> models.Model: ...
    def get_default_locale(self) -> Locale: ...
    @classmethod
    def get_translation_model(cls) -> Type[models.Model]: ...

def bootstrap_translatable_model(model: Type[models.Model], locale: Locale) -> None: ...

class BootstrapTranslatableModel(migrations.RunPython):
    def __init__(
        self, model_string: str, language_code: Optional[Any] = ...
    ): ...

class BootstrapTranslatableMixin(TranslatableMixin):
    translation_key: Any = ...
    locale: Any = ...
    @classmethod
    def check(cls, **kwargs: Any): ...

def get_translatable_models(include_subclasses: bool = ...) -> List[Type[models.Model]]: ...
def set_locale_on_new_instance(sender: Any, instance: models.Model, **kwargs: Any) -> None: ...

PAGE_MODEL_CLASSES: List[Type[Page]]

def get_page_models() -> List[Type[Page]]: ...
def get_default_page_content_type() -> ContentType: ...

class BasePageManager(models.Manager[BasePage]):
    def get_queryset(self) -> models.Manager[BasePage]: ...

PageManager: BasePageManager

class PageBase(models.base.ModelBase):
    def __init__(cls, name: Any, bases: Any, dct: Any) -> None: ...

class AbstractPage(TranslatableMixin, TreebeardPathFixMixin, MP_Node):
    objects: Any = ...

class Page(AbstractPage, index.Indexed, ClusterableModel, metaclass=PageBase):
    subpage_types: Optional[List[str]] = None
    parent_page_types: Optional[List[str]] = None
    title: models.CharField = ...
    draft_title: models.CharField = ...
    slug: models.SlugField = ...
    content_type: models.ForeignKey = ...
    live: models.BooleanField = ...
    has_unpublished_changes: models.BooleanField = ...
    url_path: models.TextField = ...
    owner: models.ForeignKey = ...
    seo_title: models.CharField = ...
    show_in_menus_default: bool = ...
    show_in_menus: models.BooleanField = ...
    search_description: models.TextField = ...
    go_live_at: models.DateTimeField = ...
    expire_at: models.DateTimeField = ...
    expired: models.BooleanField = ...
    locked: models.BooleanField = ...
    locked_at: models.DateTimeField = ...
    locked_by: models.ForeignKey = ...
    first_published_at: models.DateTimeField = ...
    last_published_at: models.DateTimeField = ...
    latest_revision_created_at: models.DateTimeField = ...
    live_revision: models.ForeignKey = ...
    alias_of: models.ForeignKey = ...
    search_fields: List[Union[BaseField, RelatedFields]] = ...
    is_creatable: bool = ...
    max_count: Optional[int] = ...
    max_count_per_parent: Optional[int] = ...
    exclude_fields_in_copy: List[str] = ...
    default_exclude_fields_in_copy: List[str] = ...
    content_panels: List[EditHandler] = ...
    promote_panels: List[EditHandler] = ...
    settings_panels: List[EditHandler] = ...
    def __init__(self, *args: Any, **kwargs: Any): ...
    def set_url_path(self, parent: Page) -> str: ...
    def get_default_locale(self) -> Locale: ...
    def full_clean(self, exclude: Optional[TypingCollection[str]] = ..., validate_unique: bool = ...) -> None: ...
    def clean(self) -> None: ...
    def is_site_root(self) -> bool: ...
    def save(
        self,
        clean: bool = ...,
        user: Optional[Any] = ...,
        log_action: bool = ...,
        **kwargs: Any
    ): ...
    def delete(self, using: Any = ..., keep_parents: bool = ...) -> Tuple[int, Dict[str, int]]: ...
    @classmethod
    def check(cls, **kwargs: Any): ...
    def specific(self): ...
    def specific_class(self): ...
    @property
    def cached_content_type(self): ...
    @property
    def localized_draft(self): ...
    @property
    def localized(self): ...
    def route(self, request: Any, path_components: Any): ...
    def get_admin_display_title(self): ...
    def save_revision(
        self,
        user: Optional[Any] = ...,
        submitted_for_moderation: bool = ...,
        approved_go_live_at: Optional[Any] = ...,
        changed: bool = ...,
        log_action: bool = ...,
        previous_revision: Optional[Any] = ...,
        clean: bool = ...,
    ): ...
    def get_latest_revision(self): ...
    def get_latest_revision_as_page(self): ...
    def update_aliases(
        self,
        *,
        revision: Optional[Any] = ...,
        user: Optional[Any] = ...,
        _content_json: Optional[Any] = ...,
        _updated_ids: Optional[Any] = ...
    ) -> None: ...
    def unpublish(
        self,
        set_expired: bool = ...,
        commit: bool = ...,
        user: Optional[Any] = ...,
        log_action: bool = ...,
    ) -> None: ...
    context_object_name: Any = ...
    def get_context(self, request: Any, *args: Any, **kwargs: Any): ...
    def get_template(self, request: Any, *args: Any, **kwargs: Any): ...
    def serve(self, request: HttpRequest, *args: Any, **kwargs: Any): ...
    def is_navigable(self): ...
    def get_url_parts(self, request: Optional[Any] = ...): ...
    def get_full_url(self, request: Optional[Any] = ...): ...
    full_url: Any = ...
    def get_url(
        self, request: Optional[Any] = ..., current_site: Optional[Any] = ...
    ): ...
    url: Any = ...
    def relative_url(self, current_site: Any, request: Optional[Any] = ...): ...
    def get_site(self): ...
    @classmethod
    def get_indexed_objects(cls): ...
    def get_indexed_instance(self): ...
    @classmethod
    def clean_subpage_models(cls): ...
    @classmethod
    def clean_parent_page_models(cls): ...
    @classmethod
    def allowed_parent_page_models(cls): ...
    @classmethod
    def allowed_subpage_models(cls): ...
    @classmethod
    def creatable_subpage_models(cls): ...
    @classmethod
    def can_exist_under(cls, parent: Any): ...
    @classmethod
    def can_create_at(cls, parent: Any): ...
    def can_move_to(self, parent: Any): ...
    @classmethod
    def get_verbose_name(cls): ...
    @property
    def status_string(self): ...
    @property
    def approved_schedule(self): ...
    def has_unpublished_subtree(self): ...
    def move(
        self, target: Any, pos: Optional[Any] = ..., user: Optional[Any] = ...
    ) -> None: ...
    def copy(
        self,
        recursive: bool = ...,
        to: Optional[Any] = ...,
        update_attrs: Optional[Any] = ...,
        copy_revisions: bool = ...,
        keep_live: bool = ...,
        user: Optional[Any] = ...,
        process_child_object: Optional[Any] = ...,
        exclude_fields: Optional[Any] = ...,
        log_action: str = ...,
        reset_translation_key: bool = ...,
        _mpnode_attrs: Optional[Any] = ...,
    ): ...
    def create_alias(
        self,
        *,
        recursive: bool = ...,
        parent: Optional[Any] = ...,
        update_slug: Optional[Any] = ...,
        update_locale: Optional[Any] = ...,
        user: Optional[Any] = ...,
        log_action: str = ...,
        reset_translation_key: bool = ...,
        _mpnode_attrs: Optional[Any] = ...
    ): ...
    def copy_for_translation(
        self,
        locale: Any,
        copy_parents: bool = ...,
        alias: bool = ...,
        exclude_fields: Optional[Any] = ...,
    ): ...
    def permissions_for_user(self, user: Any): ...
    def make_preview_request(
        self,
        original_request: Optional[Any] = ...,
        preview_mode: Optional[Any] = ...,
        extra_request_attrs: Optional[Any] = ...,
    ): ...
    DEFAULT_PREVIEW_MODES: Any = ...
    @property
    def preview_modes(self): ...
    @property
    def default_preview_mode(self): ...
    def is_previewable(self): ...
    def serve_preview(self, request: HttpRequest, mode_name: str): ...
    def get_cached_paths(self): ...
    def get_sitemap_urls(self, request: Optional[Any] = ...): ...
    def get_static_site_paths(self) -> None: ...
    def get_ancestors(self, inclusive: bool = ...): ...
    def get_descendants(self, inclusive: bool = ...): ...
    def get_siblings(self, inclusive: bool = ...): ...
    def get_next_siblings(self, inclusive: bool = ...): ...
    def get_prev_siblings(self, inclusive: bool = ...): ...
    def get_view_restrictions(self): ...
    password_required_template: Any = ...
    def serve_password_required_response(
        self, request: Any, form: Any, action_url: Any
    ): ...
    def with_content_json(self, content_json: Any): ...
    @property
    def has_workflow(self): ...
    def get_workflow(self): ...
    @property
    def workflow_in_progress(self): ...
    @property
    def current_workflow_state(self): ...
    @property
    def current_workflow_task_state(self): ...
    @property
    def current_workflow_task(self): ...

class Orderable(models.Model):
    sort_order: Any = ...
    sort_order_field: str = ...

class SubmittedRevisionsManager(models.Manager):
    def get_queryset(self): ...

class PageRevision(models.Model):
    page: Any = ...
    submitted_for_moderation: Any = ...
    created_at: Any = ...
    user: Any = ...
    content_json: Any = ...
    approved_go_live_at: Any = ...
    objects: Any = ...
    submitted_revisions: Any = ...
    def save(self, user: Optional[Any] = ..., *args: Any, **kwargs: Any) -> None: ...
    def as_page_object(self): ...
    def approve_moderation(self, user: Optional[Any] = ...) -> None: ...
    def reject_moderation(self, user: Optional[Any] = ...) -> None: ...
    def is_latest_revision(self): ...
    def publish(
        self,
        user: Optional[Any] = ...,
        changed: bool = ...,
        log_action: bool = ...,
        previous_revision: Optional[Any] = ...,
    ) -> None: ...
    def get_previous(self): ...
    def get_next(self): ...

PAGE_PERMISSION_TYPES: Any
PAGE_PERMISSION_TYPE_CHOICES: Any

class GroupPagePermission(models.Model):
    group: Any = ...
    page: Any = ...
    permission_type: Any = ...

class UserPagePermissionsProxy:
    user: Any = ...
    permissions: Any = ...
    def __init__(self, user: Any) -> None: ...
    def revisions_for_moderation(self): ...
    def for_page(self, page: Any): ...
    def explorable_pages(self): ...
    def editable_pages(self): ...
    def can_edit_pages(self): ...
    def publishable_pages(self): ...
    def can_publish_pages(self): ...
    def can_remove_locks(self): ...

class PagePermissionTester:
    user: Any = ...
    user_perms: Any = ...
    page: Any = ...
    page_is_root: Any = ...
    permissions: Any = ...
    def __init__(self, user_perms: Any, page: Any) -> None: ...
    def user_has_lock(self): ...
    def page_locked(self): ...
    def can_add_subpage(self): ...
    def can_edit(self): ...
    def can_delete(self, ignore_bulk: bool = ...): ...
    def can_unpublish(self): ...
    def can_publish(self): ...
    def can_submit_for_moderation(self): ...
    def can_set_view_restrictions(self): ...
    def can_unschedule(self): ...
    def can_lock(self): ...
    def can_unlock(self): ...
    def can_publish_subpage(self): ...
    def can_reorder_children(self): ...
    def can_move(self): ...
    def can_copy(self): ...
    def can_move_to(self, destination: Any): ...
    def can_copy_to(self, destination: Any, recursive: bool = ...): ...
    def can_view_revisions(self): ...

class BaseViewRestriction(models.Model):
    NONE: str = ...
    PASSWORD: str = ...
    GROUPS: str = ...
    LOGIN: str = ...
    RESTRICTION_CHOICES: Collection[Tuple[str, str]] = ...
    restriction_type: models.CharField = ...
    password: models.CharField = ...
    groups: models.ManyToManyField = ...
    def accept_request(self, request: HttpRequest) -> bool: ...
    def mark_as_passed(self, request: HttpRequest) -> None: ...

class PageViewRestriction(BaseViewRestriction):
    page: models.ForeignKey = ...
    passed_view_restrictions_session_key: str = ...

class BaseCollectionManager(models.Manager["BaseCollection"]):
    def get_queryset(self) -> models.Manager["BaseCollection"]: ...

CollectionManager: BaseCollectionManager

class CollectionViewRestriction(BaseViewRestriction):
    collection: models.ForeignKey = ...
    passed_view_restrictions_session_key: str = ...

class Collection(TreebeardPathFixMixin, MP_Node):
    name: models.CharField = ...
    objects: CollectionManager = ...
    node_order_by: List[str] = ...
    def get_ancestors(self, inclusive: bool = ...) -> models.QuerySet[Collection]: ...
    def get_descendants(self, inclusive: bool = ...) -> models.QuerySet[Collection]: ...
    def get_siblings(self, inclusive: bool = ...) -> models.QuerySet[Collection]: ...
    def get_next_siblings(self, inclusive: bool = ...) -> models.QuerySet[Collection]: ...
    def get_prev_siblings(self, inclusive: bool = ...) -> models.QuerySet[Collection]: ...
    def get_view_restrictions(self) -> CollectionViewRestriction: ...
    def get_indented_name(
        self, indentation_start_depth: int = ..., html: bool = ...
    ) -> str: ...

def get_root_collection_id() -> Any: ...

class CollectionMember(models.Model):
    collection: models.ForeignKey = ...
    search_fields: List[Union[RelatedFields, SearchField]] = ...

class GroupCollectionPermissionManager(models.Manager[GroupCollectionPermission]):
    def get_by_natural_key(self, group: Group, collection: Collection, permission: Permission) -> GroupCollectionPermission: ...

class GroupCollectionPermission(models.Model):
    group: Any = ...
    collection: Any = ...
    permission: Any = ...
    def natural_key(self): ...
    objects: Any = ...

class WorkflowPage(models.Model):
    page: Any = ...
    workflow: Any = ...
    def get_pages(self): ...

class WorkflowTask(Orderable):
    workflow: Any = ...
    task: Any = ...

class TaskManager(models.Manager):
    def active(self): ...

class Task(models.Model):
    name: Any = ...
    content_type: Any = ...
    active: Any = ...
    objects: Any = ...
    admin_form_fields: Any = ...
    admin_form_readonly_on_edit_fields: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def workflows(self): ...
    @property
    def active_workflows(self): ...
    @classmethod
    def get_verbose_name(cls): ...
    def specific(self): ...
    task_state_class: Any = ...
    @classmethod
    def get_task_state_class(self): ...
    def start(self, workflow_state: Any, user: Optional[Any] = ...): ...
    def on_action(
        self, task_state: Any, user: Any, action_name: Any, **kwargs: Any
    ) -> None: ...
    def user_can_access_editor(self, page: Any, user: Any): ...
    def page_locked_for_user(self, page: Any, user: Any): ...
    def user_can_lock(self, page: Any, user: Any): ...
    def user_can_unlock(self, page: Any, user: Any): ...
    def get_actions(self, page: Any, user: Any): ...
    def get_form_for_action(self, action: Any): ...
    def get_template_for_action(self, action: Any): ...
    def get_task_states_user_can_moderate(self, user: Any, **kwargs: Any): ...
    @classmethod
    def get_description(cls): ...
    def deactivate(self, user: Optional[Any] = ...) -> None: ...

class WorkflowManager(models.Manager):
    def active(self): ...

class Workflow(ClusterableModel):
    name: Any = ...
    active: Any = ...
    objects: Any = ...
    @property
    def tasks(self): ...
    def start(self, page: Any, user: Any): ...
    def deactivate(self, user: Optional[Any] = ...) -> None: ...
    def all_pages(self): ...

class GroupApprovalTask(Task):
    groups: Any = ...
    admin_form_fields: Any = ...
    admin_form_widgets: Any = ...
    def start(self, workflow_state: Any, user: Optional[Any] = ...): ...
    def user_can_access_editor(self, page: Any, user: Any): ...
    def page_locked_for_user(self, page: Any, user: Any): ...
    def user_can_lock(self, page: Any, user: Any): ...
    def user_can_unlock(self, page: Any, user: Any): ...
    def get_actions(self, page: Any, user: Any): ...
    def get_task_states_user_can_moderate(self, user: Any, **kwargs: Any): ...
    @classmethod
    def get_description(cls): ...

class WorkflowStateManager(models.Manager):
    def active(self): ...

class WorkflowState(models.Model):
    STATUS_IN_PROGRESS: str = ...
    STATUS_APPROVED: str = ...
    STATUS_NEEDS_CHANGES: str = ...
    STATUS_CANCELLED: str = ...
    STATUS_CHOICES: Any = ...
    page: Any = ...
    workflow: Any = ...
    status: Any = ...
    created_at: Any = ...
    requested_by: Any = ...
    current_task_state: Any = ...
    on_finish: Any = ...
    objects: Any = ...
    def clean(self) -> None: ...
    def save(self, *args: Any, **kwargs: Any): ...
    def resume(self, user: Optional[Any] = ...): ...
    def user_can_cancel(self, user: Any): ...
    def update(
        self, user: Optional[Any] = ..., next_task: Optional[Any] = ...
    ) -> None: ...
    @property
    def successful_task_states(self): ...
    def get_next_task(self): ...
    def cancel(self, user: Optional[Any] = ...) -> None: ...
    def finish(self, user: Optional[Any] = ...) -> None: ...
    def copy_approved_task_states_to_revision(self, revision: Any) -> None: ...
    def revisions(self): ...
    def all_tasks_with_status(self): ...
    def all_tasks_with_state(self): ...
    @property
    def is_active(self): ...
    @property
    def is_at_final_task(self): ...

class TaskStateManager(models.Manager):
    def reviewable_by(self, user: Any): ...

class TaskState(models.Model):
    STATUS_IN_PROGRESS: str = ...
    STATUS_APPROVED: str = ...
    STATUS_REJECTED: str = ...
    STATUS_SKIPPED: str = ...
    STATUS_CANCELLED: str = ...
    STATUS_CHOICES: Any = ...
    workflow_state: Any = ...
    page_revision: Any = ...
    task: Any = ...
    status: Any = ...
    started_at: Any = ...
    finished_at: Any = ...
    finished_by: Any = ...
    comment: Any = ...
    content_type: Any = ...
    exclude_fields_in_copy: Any = ...
    default_exclude_fields_in_copy: Any = ...
    objects: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def specific(self): ...
    def approve(
        self, user: Optional[Any] = ..., update: bool = ..., comment: str = ...
    ): ...
    def reject(
        self, user: Optional[Any] = ..., update: bool = ..., comment: str = ...
    ): ...
    def task_type_started_at(self): ...
    def cancel(
        self, user: Optional[Any] = ..., resume: bool = ..., comment: str = ...
    ): ...
    def copy(
        self, update_attrs: Optional[Any] = ..., exclude_fields: Optional[Any] = ...
    ): ...
    def get_comment(self): ...
    def log_state_change_action(self, user: Any, action: Any) -> None: ...

class BaseLogEntryManager(models.Manager):
    def log_action(self, instance: Any, action: Any, **kwargs: Any): ...
    def get_for_model(self, model: Any): ...
    def get_for_user(self, user_id: Any): ...

class PageLogEntryManager(BaseLogEntryManager):
    def log_action(self, instance: Any, action: Any, **kwargs: Any): ...

class BaseLogEntry(models.Model):
    content_type: Any = ...
    label: Any = ...
    action: Any = ...
    data_json: Any = ...
    timestamp: Any = ...
    user: Any = ...
    content_changed: Any = ...
    deleted: Any = ...
    objects: Any = ...
    def user_display_name(self): ...
    def data(self): ...
    def object_verbose_name(self): ...
    def object_id(self) -> None: ...
    def comment(self): ...

class PageLogEntry(BaseLogEntry):
    page: Any = ...
    revision: Any = ...
    objects: Any = ...
    def object_id(self): ...
